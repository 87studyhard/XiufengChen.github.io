<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Async Actions - Xiufeng</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="This article is based on Async Actions tutorial and a solution from stackoverflow about how to dispatch a Redux action with a timeout or any other asynchronous request.
Why Using Thunk?本文的第一部分我想先借用Red">
<meta property="og:type" content="article">
<meta property="og:title" content="Async Actions">
<meta property="og:url" content="http://xiufengchen.github.io/2016/08/15/Async-Actions/index.html">
<meta property="og:site_name" content="Xiufeng">
<meta property="og:description" content="This article is based on Async Actions tutorial and a solution from stackoverflow about how to dispatch a Redux action with a timeout or any other asynchronous request.
Why Using Thunk?本文的第一部分我想先借用Red">
<meta property="og:updated_time" content="2016-08-17T04:07:23.107Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Async Actions">
<meta name="twitter:description" content="This article is based on Async Actions tutorial and a solution from stackoverflow about how to dispatch a Redux action with a timeout or any other asynchronous request.
Why Using Thunk?本文的第一部分我想先借用Red">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-65933410-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


</head>

<body>
  <div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo logo-text" href="/">Xiufeng</a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
          <a class="main-nav-link" href="/atom.xml">Rss</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xiufengchen.github.io"></form>
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer"><article id="post-Async-Actions" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Async Actions
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/08/15/Async-Actions/" class="article-date">
  <time datetime="2016-08-16T01:55:13.000Z" itemprop="datePublished">2016-08-15</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>This article is based on <a href="http://redux.js.org/docs/advanced/AsyncActions.html" target="_blank" rel="external">Async Actions tutorial</a> and a <a href="http://stackoverflow.com/questions/35411423/how-to-dispatch-a-redux-action-with-a-timeout/35415559#35415559" target="_blank" rel="external">solution from stackoverflow</a> about how to dispatch a Redux action with a timeout or any other asynchronous request.</p>
<h1 id="Why-Using-Thunk"><a href="#Why-Using-Thunk" class="headerlink" title="Why Using Thunk?"></a>Why Using Thunk?</h1><p>本文的第一部分我想先借用Redux作者Dan Abramov在stackoverflow上的回答来阐述一下使用thunk的原理。</p>
<p><a href="http://stackoverflow.com/questions/35411423/how-to-dispatch-a-redux-action-with-a-timeout" target="_blank" rel="external">How to dispatch a Redux action with a timeout?</a></p>
<h2 id="dispatch-action"><a href="#dispatch-action" class="headerlink" title="dispatch(action)"></a>dispatch(action)</h2><p>首先来看一下dipatch(action)的API。dispatch 一个action是触发state改变的唯一方法。store的reducer方法将会同时调用getState()的结果和action。reducer方法的返回值就是新的state，一旦状态改变就会通知listener。</p>
<h3 id="Arguments"><a href="#Arguments" class="headerlink" title="Arguments"></a>Arguments</h3><p>action是向store添加数据的唯一方法，无论该数据是通过UI事件，调用外部回调函数，还是通过WebSockets 得到的。</p>
<h3 id="Returns"><a href="#Returns" class="headerlink" title="Returns"></a>Returns</h3><p>被调度了的action，一般情况下该返回值是Object。</p>
<h2 id="Writing-Async-Code-Inline"><a href="#Writing-Async-Code-Inline" class="headerlink" title="Writing Async Code Inline"></a>Writing Async Code Inline</h2><p>这是使用redux实现setTimeout最简单的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">store.dispatch(&#123; type: <span class="string">'SHOW_NOTIFICATION'</span>, text: <span class="string">'You logged in.'</span> &#125;)</div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">  store.dispatch(&#123; type: <span class="string">'HIDE_NOTIFICATION'</span> &#125;)</div><div class="line">&#125;, <span class="number">5000</span>)</div></pre></td></tr></table></figure>
<p>类似的，从一个connected组件内部使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.props.dispatch(&#123; type: <span class="string">'SHOW_NOTIFICATION'</span>, text: <span class="string">'You logged in.'</span> &#125;)</div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">  <span class="keyword">this</span>.props.dispatch(&#123; type: <span class="string">'HIDE_NOTIFICATION'</span> &#125;)</div><div class="line">&#125;, <span class="number">5000</span>)</div></pre></td></tr></table></figure>
<p>这两者唯一的区别就是，在一个connected组件中，我们无法得到store本身，只能通过dispatch()方法或者当做组件props来用的action creator函数，其实上面两者没有太大区别。</p>
<p>Writing async code inline当然也有缺点，如果在不同组件dispatch同一action的时候，你不希望发生拼写错误，你可能会将同一个action提取到action creator中，以后再dispatch中调用这个action creator就可以了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// actions.js</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">showNotification</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123; type: <span class="string">'SHOW_NOTIFICATION'</span>, text &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">hideNotification</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123; type: <span class="string">'HIDE_NOTIFICATION'</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// component.js</span></div><div class="line"><span class="keyword">import</span> &#123; showNotification, hideNotification &#125; <span class="keyword">from</span> <span class="string">'../actions'</span></div><div class="line"></div><div class="line"><span class="keyword">this</span>.props.dispatch(showNotification(<span class="string">'You just logged in.'</span>))</div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">  <span class="keyword">this</span>.props.dispatch(hideNotification())</div><div class="line">&#125;, <span class="number">5000</span>)</div></pre></td></tr></table></figure>
<p>当然，如果你已经提前将他们绑定（connect）到了组件上，你还可以使用这种方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.props.showNotification(<span class="string">'You just logged in.'</span>)</div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">  <span class="keyword">this</span>.props.hideNotification()</div><div class="line">&#125;, <span class="number">5000</span>)</div></pre></td></tr></table></figure>
<p>以上我们尚未使用到任何middleware或者其他高级概念。</p>
<h2 id="Extracting-Async-Action-Creator"><a href="#Extracting-Async-Action-Creator" class="headerlink" title="Extracting Async Action Creator"></a>Extracting Async Action Creator</h2><p>上面的方法在应对简单问题是或许还可以，但是也存在一些问题：</p>
<ol>
<li>当你想show a notification时，它迫使你使用这种逻辑</li>
<li>每个notification没有ID识别，所以当你显示两个很快的notifications时会出现紊乱情况。当第一个timeout完成，它将dispatch HIDE_NOTIFICATION，但是可能错误的隐藏了第二个比timeout快的notification。简单地说想显示两个notification，经历一个timeout隐藏第一个notification，但是隐藏了第二个notification。</li>
</ol>
<p>为了解决这些问题，我们需要将timeout逻辑和dispatch show和hide action提取到一个函数里面，并给一个ID变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// actions.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">showNotification</span>(<span class="params">id, text</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123; type: <span class="string">'SHOW_NOTIFICATION'</span>, id, text &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hideNotification</span>(<span class="params">id</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123; type: <span class="string">'HIDE_NOTIFICATION'</span>, id &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> nextNotificationId = <span class="number">0</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">showNotificationWithTimeout</span>(<span class="params">dispatch, text</span>) </span>&#123;</div><div class="line">  <span class="comment">// Assigning IDs to notifications lets reducer ignore HIDE_NOTIFICATION</span></div><div class="line">  <span class="comment">// for the notification that is not currently visible.</span></div><div class="line">  <span class="comment">// Alternatively, we could store the interval ID and call</span></div><div class="line">  <span class="comment">// clearInterval(), but we’d still want to do it in a single place.</span></div><div class="line">  <span class="keyword">const</span> id = nextNotificationId++</div><div class="line">  dispatch(showNotification(id, text))</div><div class="line"></div><div class="line">  setTimeout(() =&gt; &#123;</div><div class="line">    dispatch(hideNotification(id))</div><div class="line">  &#125;, <span class="number">5000</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，他们此时都在actions 文件里。现在组件中就可以调用showNotificationWithTimeout来克服上面两点缺陷了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// component.js</span></div><div class="line">showNotificationWithTimeout(<span class="keyword">this</span>.props.dispatch, <span class="string">'You just logged in.'</span>)</div><div class="line"></div><div class="line"><span class="comment">// otherComponent.js</span></div><div class="line">showNotificationWithTimeout(<span class="keyword">this</span>.props.dispatch, <span class="string">'You just logged out.'</span>)</div></pre></td></tr></table></figure>
<p>为什么showNotificationWithTimeout()接受dispatch作为第一个参数？因为它需要向store里面dispatch actions。正常情况下，一个组件可以使用dispatch，但现在我们希望一个外部的函数接管dispatch行为，我们就要将dispatch赋予这个函数。</p>
<p>如果在actions.js文件中，你有一个singleton store导入到里面，你可以直接使用store.dispatch()：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// store.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(reducer)</div><div class="line"></div><div class="line"><span class="comment">// actions.js</span></div><div class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> nextNotificationId = <span class="number">0</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">showNotificationWithTimeout</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> id = nextNotificationId++</div><div class="line">  store.dispatch(showNotification(id, text))</div><div class="line"></div><div class="line">  setTimeout(() =&gt; &#123;</div><div class="line">    store.dispatch(hideNotification(id))</div><div class="line">  &#125;, <span class="number">5000</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// component.js</span></div><div class="line">showNotificationWithTimeout(<span class="string">'You just logged in.'</span>)</div><div class="line"></div><div class="line"><span class="comment">// otherComponent.js</span></div><div class="line">showNotificationWithTimeout(<span class="string">'You just logged out.'</span>)</div></pre></td></tr></table></figure>
<p>上面的代码看起来简洁，但是我们并不推荐这种做法。主要原因在于它强制性的让store成为一个singleton。这一点在实现server rendering的时候会变得非常困难。在服务器中，你希望每个请求有它自己的store，每个用户因此可以得到不同的preloaded data。一个singleton store使得测试也变得困难，因为你不能在测试action creators时模拟一个store，singleton store会从某个特定的module中引用一个真正的store。并且我们也无法在外部重置state了。所以除非你清楚你的应用不会server rendering，我们不会推荐你用这种方法。</p>
<h2 id="Thunk-Middleware"><a href="#Thunk-Middleware" class="headerlink" title="Thunk Middleware"></a>Thunk Middleware</h2><p>接下来就到正题了。</p>
<p>对于简单的应用来说，上面的方法足够用了。但是当应用规模增加，这种方法有些不方便使用。举例来说，我们想将 container 和 component 分离，这种方法就不太适合。因为任何想要使用以上方法dispatch async actions的组件必须接受 dispatch 作为他的 prop，该组件才能将 dispatch 传递到函数中。但是我们并不能使用 connect() 绑定 showNotificationWithTimeout()，因为它根本不是一个action creator，<strong>它没有返回一个Redux action</strong>。并且，在写代码的过程中不容易记忆和区分哪个代码是像 showNotification() 那样的sync代码，哪些代码是像 showNotificationWithTimeout() 那样的 async 代码。</p>
<p>上面这些问题使得我们寻找一个合适的方法来规范这种<strong>将dispatch参数提供给helper function</strong>的模式，来帮助 Redux 认清那样的async action creator只是正常action creator的一种特殊形式，而非完全不同的方法。</p>
<p>Redux thunk 可以帮助 Redux 识别一些函数形式的actions。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">'redux'</span></div><div class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> store = createStore(</div><div class="line">  reducer,</div><div class="line">  applyMiddleware(thunk)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// It still recognizes plain object actions</span></div><div class="line">store.dispatch(&#123; type: <span class="string">'INCREMENT'</span> &#125;)</div><div class="line"></div><div class="line"><span class="comment">// But with thunk middleware, it also recognizes functions</span></div><div class="line">store.dispatch(<span class="function"><span class="keyword">function</span> (<span class="params">dispatch</span>) </span>&#123;</div><div class="line">  <span class="comment">// ... which themselves may dispatch many times</span></div><div class="line">  dispatch(&#123; type: <span class="string">'INCREMENT'</span> &#125;)</div><div class="line">  dispatch(&#123; type: <span class="string">'INCREMENT'</span> &#125;)</div><div class="line">  dispatch(&#123; type: <span class="string">'INCREMENT'</span> &#125;)</div><div class="line"></div><div class="line">  setTimeout(() =&gt; &#123;</div><div class="line">    <span class="comment">// ... even asynchronously!</span></div><div class="line">    dispatch(&#123; type: <span class="string">'DECREMENT'</span> &#125;)</div><div class="line">  &#125;, <span class="number">1000</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>当这个middleware启动时，如果你想 dispatch 一个function，Redux thunk middleware会给这个函数传递一个dispatch 参数。它同样包含actions，你不必担心你的reducers不识别function参数，因为你的reducer还是只接收到object action，可能来源于直接object传递，也可能来源于这个函数传递的。</p>
<p>目前来看这个功能好像不是很有用，不过它只是在这里用不到，让我们先来创建一个showNotificationWithTimeout() 的action creator看看：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// actions.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">showNotification</span>(<span class="params">id, text</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123; type: <span class="string">'SHOW_NOTIFICATION'</span>, id, text &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hideNotification</span>(<span class="params">id</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123; type: <span class="string">'HIDE_NOTIFICATION'</span>, id &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> nextNotificationId = <span class="number">0</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">showNotificationWithTimeout</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">dispatch</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> id = nextNotificationId++</div><div class="line">    dispatch(showNotification(id, text))</div><div class="line"></div><div class="line">    setTimeout(() =&gt; &#123;</div><div class="line">      dispatch(hideNotification(id))</div><div class="line">    &#125;, <span class="number">5000</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们注意到这个函数和之前的的函数差不多，而且它并没有接受dispatch作为第一个参数，它返回了一个函数这个函数接受了dispatch作为它的第一个参数。那么我们在component中怎么使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// component.js</span></div><div class="line">showNotificationWithTimeout(<span class="string">'You just logged in.'</span>)(<span class="keyword">this</span>.props.dispatch)</div></pre></td></tr></table></figure>
<p>如果Redux Thunk middleware启动的情况下，每次你希望 dispatch 一个 function 而不是 action object的时候，这个middleware就会调用那个带dispatch方法作为第一个参数的函数。</p>
<p>因此我们可以用以下方法代替：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// component.js</span></div><div class="line"><span class="keyword">this</span>.props.dispatch(showNotificationWithTimeout(<span class="string">'You just logged in.'</span>))</div><div class="line"></div><div class="line">等价于</div><div class="line"><span class="keyword">this</span>.props.dispatch(</div><div class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">dispatch</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> id = nextNotificationId++</div><div class="line">    dispatch(showNotification(id, <span class="string">'You just logged in.'</span>))</div><div class="line">    setTimeout(() =&gt; &#123;</div><div class="line">      dispatch(hideNotification(id))</div><div class="line">    &#125;, <span class="number">5000</span>)</div><div class="line">  &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<p>这样，dispatch一个 async action 就和 dispatch 一个 sync action 在写法上看起来一样了。因为component不应该在意一个事情的发生是同步的还是异步的。既然我们 已经让 Redux 知道怎样识别一个thunk action creator了，那么我们应该可以在任何可以使用一般action creator的地方使用 thunk action creator，例如我们将它配合connect()使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// actions.js</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">showNotification</span>(<span class="params">id, text</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123; type: <span class="string">'SHOW_NOTIFICATION'</span>, id, text &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hideNotification</span>(<span class="params">id</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123; type: <span class="string">'HIDE_NOTIFICATION'</span>, id &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> nextNotificationId = <span class="number">0</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">showNotificationWithTimeout</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">dispatch</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> id = nextNotificationId++</div><div class="line">    dispatch(showNotification(id, text))</div><div class="line"></div><div class="line">    setTimeout(() =&gt; &#123;</div><div class="line">      dispatch(hideNotification(id))</div><div class="line">    &#125;, <span class="number">5000</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// component.js</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keyword">this</span>.props.showNotificationWithTimeout(<span class="string">'You just logged in.'</span>)</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(</div><div class="line">  mapStateToProps,</div><div class="line">  &#123; showNotificationWithTimeout &#125;</div><div class="line">)(MyComponent)</div></pre></td></tr></table></figure>
<h2 id="Reading-State-in-Thunks"><a href="#Reading-State-in-Thunks" class="headerlink" title="Reading State in Thunks"></a>Reading State in Thunks</h2><p>通常情况下，你的reducer包含了下个state的业务逻辑。然而，只有在action被dispatched以后reducer才开始工作。如果此时你的thunk action creator有其他的副作用违背这一规则，例如调用远程API，你应该怎样做？或者说你怎样希望避免action 被dispatched以后reducer才开始工作这一规则？</p>
<p>在没有使用thunk的情况下，你会在component内部检查：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// component.js</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.props.areNotificationsEnabled) &#123;</div><div class="line">  showNotificationWithTimeout(<span class="keyword">this</span>.props.dispatch, <span class="string">'You just logged in.'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是这样做就违背了将重复逻辑提取成一个函数供不同component复用的原则。庆幸的是，Redux Thunk提供了一个方法来read the current state of the Redux store。除了dispatch以外，它还传递了一个 getState 作为thunk action creator 返回函数的第二个参数。这样就使得thunk能够读取store的当前 state了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> nextNotificationId = <span class="number">0</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">showNotificationWithTimeout</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">dispatch, getState</span>) </span>&#123;</div><div class="line">    <span class="comment">// Unlike in a regular action creator, we can exit early in a thunk</span></div><div class="line">    <span class="comment">// Redux doesn’t care about its return value (or lack of it)</span></div><div class="line">    <span class="keyword">if</span> (!getState().areNotificationsEnabled) &#123;</div><div class="line">      <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> id = nextNotificationId++</div><div class="line">    dispatch(showNotification(id, text))</div><div class="line"></div><div class="line">    setTimeout(() =&gt; &#123;</div><div class="line">      dispatch(hideNotification(id))</div><div class="line">    &#125;, <span class="number">5000</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Don’t abuse this pattern. It is good for bailing out of API calls when there is cached data available, but it is not a very good foundation to build your business logic upon. If you use <code>getState()</code> only to conditionally dispatch different actions, consider putting the business logic into the reducers instead.</p>
<h1 id="Async-Tutorial"><a href="#Async-Tutorial" class="headerlink" title="Async Tutorial"></a>Async Tutorial</h1><h2 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h2><p>当我们调用一个异步请求时，有两个重要时间点：一是开始调用的时间，二是收到应答的时间或者timeout时间。这两个时间点都需要应用状态的改变，为了改变应用状态，我们需要调度（dispatch） reducer同步处理的actions，一般情况下，任何API请求我们需要调度至少三个不同的actions。</p>
<ol>
<li>一个action通知reducer请求开始了。</li>
<li>一个action通知reducer请求成功了。</li>
<li>一个action通知reducer请求失败了。</li>
</ol>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123; type: <span class="string">'FETCH_POSTS'</span> &#125;</div><div class="line">&#123; type: <span class="string">'FETCH_POSTS'</span>, status: <span class="string">'error'</span>, error: <span class="string">'Oops'</span> &#125;</div><div class="line">&#123; type: <span class="string">'FETCH_POSTS'</span>, status: <span class="string">'success'</span>, response: &#123; ... &#125; &#125;</div></pre></td></tr></table></figure>
<h2 id="Synchronous-Action-Creators"><a href="#Synchronous-Action-Creators" class="headerlink" title="Synchronous Action Creators"></a>Synchronous Action Creators</h2><p>让我们使用创建同步action creators的方法调用reddit的API举个例子。</p>
<p>选择reddit的subreddit功能和目前调用API联系不大，所以暂时省略，完整的action流程是先选择subreddit，再调用API。让我们直接来看REQUEST_POSTS action：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> REQUEST_POSTS = <span class="string">'REQUEST_POSTS'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">requestPosts</span>(<span class="params">subreddit</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    type: REQUEST_POSTS,</div><div class="line">    subreddit</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当响应到来时：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> RECEIVE_POSTS = <span class="string">'RECEIVE_POSTS'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">receivePosts</span>(<span class="params">subreddit, json</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    type: RECEIVE_POSTS,</div><div class="line">    subreddit,</div><div class="line">    posts: json.data.children.map(child =&gt; child.data),</div><div class="line">    receivedAt: <span class="built_in">Date</span>.now()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由此可见同步调用API的action creator需要创建一系列相关的actions。目前代码中省略了错误处理。</p>
<h2 id="Handling-Actions"><a href="#Handling-Actions" class="headerlink" title="Handling Actions"></a>Handling Actions</h2><p>下面是每个Actions的reducer实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span></div><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">  SELECT_SUBREDDIT, INVALIDATE_SUBREDDIT,</div><div class="line">  REQUEST_POSTS, RECEIVE_POSTS</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'../actions'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectedSubreddit</span>(<span class="params">state = 'reactjs', action</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">    <span class="keyword">case</span> SELECT_SUBREDDIT:</div><div class="line">      <span class="keyword">return</span> action.subreddit</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      <span class="keyword">return</span> state</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">posts</span>(<span class="params">state = &#123;</span></span></div><div class="line">  isFetching: false,</div><div class="line">  didInvalidate: false,</div><div class="line">  items: []</div><div class="line">&#125;, action) &#123;</div><div class="line">  <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">    <span class="keyword">case</span> INVALIDATE_SUBREDDIT:</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</div><div class="line">        didInvalidate: <span class="literal">true</span></div><div class="line">      &#125;)</div><div class="line">    <span class="keyword">case</span> REQUEST_POSTS:</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</div><div class="line">        isFetching: <span class="literal">true</span>,</div><div class="line">        didInvalidate: <span class="literal">false</span></div><div class="line">      &#125;)</div><div class="line">    <span class="keyword">case</span> RECEIVE_POSTS:</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</div><div class="line">        isFetching: <span class="literal">false</span>,</div><div class="line">        didInvalidate: <span class="literal">false</span>,</div><div class="line">        items: action.posts,</div><div class="line">        lastUpdated: action.receivedAt</div><div class="line">      &#125;)</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      <span class="keyword">return</span> state</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">postsBySubreddit</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">    <span class="keyword">case</span> INVALIDATE_SUBREDDIT:</div><div class="line">    <span class="keyword">case</span> RECEIVE_POSTS:</div><div class="line">    <span class="keyword">case</span> REQUEST_POSTS:</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</div><div class="line">        [action.subreddit]: posts(state[action.subreddit], action)</div><div class="line">      &#125;)</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      <span class="keyword">return</span> state</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> rootReducer = combineReducers(&#123;</div><div class="line">  postsBySubreddit,</div><div class="line">  selectedSubreddit</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> rootReducer</div></pre></td></tr></table></figure>
<h2 id="Async-Action-Creators"><a href="#Async-Action-Creators" class="headerlink" title="Async Action Creators"></a>Async Action Creators</h2><p>那么我们怎样使用同步action creators 来实现网络请求？通常情况下我们使用Redux Thunk middleware。使用这个middleware，一个action creator能够返回一个function而非一个action object，这样，action creator就变成了thunk。当一个action creator返回一个function， 这个function将会被Redux Thunk middleware执行。</p>
<p>下面我们就来定义这些特殊的thunk action creators：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> fetch <span class="keyword">from</span> <span class="string">'isomorphic-fetch'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> REQUEST_POSTS = <span class="string">'REQUEST_POSTS'</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestPosts</span>(<span class="params">subreddit</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    type: REQUEST_POSTS,</div><div class="line">    subreddit</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> RECEIVE_POSTS = <span class="string">'RECEIVE_POSTS'</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">receivePosts</span>(<span class="params">subreddit, json</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    type: RECEIVE_POSTS,</div><div class="line">    subreddit,</div><div class="line">    posts: json.data.children.map(child =&gt; child.data),</div><div class="line">    receivedAt: <span class="built_in">Date</span>.now()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Meet our first thunk action creator!</span></div><div class="line"><span class="comment">// Though its insides are different, you would use it just like any other action creator:</span></div><div class="line"><span class="comment">// store.dispatch(fetchPosts('reactjs'))</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchPosts</span>(<span class="params">subreddit</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// Thunk middleware knows how to handle functions.</span></div><div class="line">  <span class="comment">// It passes the dispatch method as an argument to the function,</span></div><div class="line">  <span class="comment">// thus making it able to dispatch actions itself.</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">dispatch</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// First dispatch: the app state is updated to inform</span></div><div class="line">    <span class="comment">// that the API call is starting.</span></div><div class="line"></div><div class="line">    dispatch(requestPosts(subreddit))</div><div class="line"></div><div class="line">    <span class="comment">// The function called by the thunk middleware can return a value,</span></div><div class="line">    <span class="comment">// that is passed on as the return value of the dispatch method.</span></div><div class="line"></div><div class="line">    <span class="comment">// In this case, we return a promise to wait for.</span></div><div class="line">    <span class="comment">// This is not required by thunk middleware, but it is convenient for us.</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> fetch(<span class="string">`http://www.reddit.com/r/<span class="subst">$&#123;subreddit&#125;</span>.json`</span>)</div><div class="line">      .then(response =&gt; response.json())</div><div class="line">      .then(json =&gt;</div><div class="line"></div><div class="line">        <span class="comment">// We can dispatch many times!</span></div><div class="line">        <span class="comment">// Here, we update the app state with the results of the API call.</span></div><div class="line"></div><div class="line">        dispatch(receivePosts(subreddit, json))</div><div class="line">      )</div><div class="line"></div><div class="line">      <span class="comment">// In a real world app, you also want to</span></div><div class="line">      <span class="comment">// catch any error in the network call.</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此处使用了fetch API，替换大多数人使用的XMLHttpRequest，因为一般浏览器中，XMLHttpRequest并不是原生支持的，所以我们推荐使用isomorphic-fetch库。</p>
<p>需要注意的是，任何fetch polfill 都假设应用中存在Promise polyfill，所以最简单确保你的应用中含有Promise polyfill的方法就是在任何代码执行之前，入口处enable Babel’s ES6 polyfill。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Do this once before any other code in your app</span></div><div class="line"><span class="keyword">import</span> <span class="string">'babel-polyfill'</span></div></pre></td></tr></table></figure>
<p>我们怎样将thunk middleware加入到dispatch机制中来？答案是使用Redux中的applyMiddleware() store enhancer。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> thunkMiddleware <span class="keyword">from</span> <span class="string">'redux-thunk'</span></div><div class="line"><span class="keyword">import</span> createLogger <span class="keyword">from</span> <span class="string">'redux-logger'</span></div><div class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">'redux'</span></div><div class="line"><span class="keyword">import</span> &#123; selectSubreddit, fetchPosts &#125; <span class="keyword">from</span> <span class="string">'./actions'</span></div><div class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">'./reducers'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> loggerMiddleware = createLogger()</div><div class="line"></div><div class="line"><span class="keyword">const</span> store = createStore(</div><div class="line">  rootReducer,</div><div class="line">  applyMiddleware(</div><div class="line">    thunkMiddleware, <span class="comment">// lets us dispatch() functions</span></div><div class="line">    loggerMiddleware <span class="comment">// neat middleware that logs actions</span></div><div class="line">  )</div><div class="line">)</div><div class="line"></div><div class="line">store.dispatch(selectSubreddit(<span class="string">'reactjs'</span>))</div><div class="line">store.dispatch(fetchPosts(<span class="string">'reactjs'</span>)).then(() =&gt;</div><div class="line">  <span class="built_in">console</span>.log(store.getState())</div><div class="line">)</div></pre></td></tr></table></figure>
<p>Thunk的优点就在于它们能调度（dispatch）相互之间的结果。</p>

      
    </div>
    
    
      <footer class="article-footer">
        
      </footer>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/09/02/Bit-Manipulation/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-title"><span>&lt;</span>&nbsp;
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2016/07/15/Working-with-Google-Map-API-on-Reactjs-C/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Working with Google Map API on Reactjs&nbsp;<span>&gt;</span></div>
    </a>
  
</nav>

  
</article>




<div class="share_addthis">
  <div class="sharing addthis_toolbox share">
    <a class="addthis_button_facebook_like"></a>
    <a class="addthis_button_tweet"></a>
    <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-560c64c35486b3d4" async="async"></script>
</div>





</section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Xiufeng Chen&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    

<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div>
</body>
</html>