<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> List Node Summary · Xiufeng</title><meta name="description" content="List Node Summary - Xiufeng Chen"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sonnieme" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/XiufengChen" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">List Node Summary</h1><div class="post-info">Mar 2, 2016</div><div class="post-content"><p>These listnode questions come from leetcode, including basic kinds of listnode question and answers.</p>
<h2 id="Remove-nth-Node-from-End"><a href="#Remove-nth-Node-from-End" class="headerlink" title="Remove nth Node from End"></a>Remove nth Node from End</h2><p>Linked List 有关的题目都要首先创建一个结点newHead作为返回值。可能返回newHead.next。<br>首先将newHead.next指针指向head，便于以后遍历。<br>当选择==快慢指针方法==时，将快慢指针初始化到head结点的前一个结点。<br>快慢指针同时移动时，注意while判定条件为fast.next!=null，表示指针走到最后一个结点就停止了。<br>删除第n个结点与fast指针无关，只需要slow.next = slow.next.next。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    ListNode newHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">    newHead.next = head;</div><div class="line">    ListNode fast, slow;</div><div class="line">    fast = newHead;</div><div class="line">    slow = newHead;</div><div class="line">    </div><div class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</div><div class="line">    	fast = fast.next;</div><div class="line">        n--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(fast.next != <span class="keyword">null</span>)&#123;</div><div class="line">    	fast = fast.next;</div><div class="line">        slow = slow.next;</div><div class="line">    &#125;</div><div class="line">    slow.next = slow.next.next;</div><div class="line">    <span class="keyword">return</span> newHead.next;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="Remove-Duplicates-from-Sorted-List"><a href="#Remove-Duplicates-from-Sorted-List" class="headerlink" title="Remove Duplicates from Sorted List"></a>Remove Duplicates from Sorted List</h2><p>从一个单链表里删除重复值，只需用一个指针就行。While中的if判断是否相等，若相等，下一node向前走一下，并不是现在的指针向下走一下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    ListNode newHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</div><div class="line">    newHead.next = head;</div><div class="line">    ListNode pointer;</div><div class="line">    pointer = newHead.next;</div><div class="line">    <span class="keyword">while</span>(pointer.next!=<span class="keyword">null</span>)&#123;</div><div class="line">    	<span class="keyword">if</span>(pointer.val==pointer.next.val)&#123;</div><div class="line">        	pointer.next = pointer.next.next;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">        	pointer = pointer.next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newHead.next;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>##Palindrome Linked List<br>判断一个单链表是否为回文结构（<em>正向念，反向念全是同一个顺序</em>）。==主要方法为找到中点，翻转前半部分链表，再开始判断。==<br>查找中点的代码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">findMiddle</span><span class="params">(ListNode h)</span></span>&#123;</div><div class="line">    ListNode newHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">    ListNode fast, slow = newHead;</div><div class="line">    <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;fast.next!=<span class="keyword">null</span>)&#123;</div><div class="line">    	fast=fast.next.next;</div><div class="line">    	slow=slow.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> slow;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">    ListNode prev = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</div><div class="line">    	ListNode next = head.next;</div><div class="line">        head.next = prev;</div><div class="line">        prev = head;</div><div class="line">        head next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> prev;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Reverse-Linked-List"><a href="#Reverse-Linked-List" class="headerlink" title="Reverse Linked List"></a>Reverse Linked List</h2><p>翻转单链表，以及处理单链表问题，均可用iterator法或者recursive法。<br>Recursive法要维护两个指针，java中要创建两个新的ListNode。一个赋值head.next，一个是新的head。递归函数中前面是要断开的结点，后面是要去添加的结点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> reverseListInt(head,<span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseListInt</span><span class="params">(ListNode head, ListNode newHead)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> newHead;</div><div class="line">    ListNode next = head.next;</div><div class="line">    head.next = newHead;</div><div class="line">    <span class="keyword">return</span> reverseListInt(next,head);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Iterator法也是维护两个指针，先创建一个新的ListNode的head，用于最后结果的返回。再在while循环中创建next 用来保存下一个需要链接的结点。移动过程为head指向newhead, head变为newhead，next变为head。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">    ListNode newHead = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</div><div class="line">    	ListNode next = head.next;</div><div class="line">        head.next = newHead;</div><div class="line">        newHead = head;</div><div class="line">        head = next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newHead;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Remove-Value-in-Linked-List"><a href="#Remove-Value-in-Linked-List" class="headerlink" title="Remove Value in Linked List"></a>Remove Value in Linked List</h2><p>大多数的linkedlist问题可以通过递归和非递归算法实现。特别是问题中涉及到迭代遍历问题，都可以用recursive方法。<br>Recursive 法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    head.next = removeElements(head.next, val);</div><div class="line">    <span class="keyword">return</span> head.val == val ? head.next : head;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Iterative 法，不用刻意赋值val和next，创建一个指针，可以直接赋值p.next=p.next.next。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    ListNode newHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">    newHead.next = head;</div><div class="line">    ListNode pointer = newHead;</div><div class="line">    <span class="keyword">while</span>(pointer.next!=<span class="keyword">null</span>)&#123;</div><div class="line">    	<span class="keyword">if</span>(pointer.next.val==val)&#123;</div><div class="line">        	pointer.next = pointer.next.next;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">        	pointer = pointer.next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newHead.next;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Two-Linked-List-Intersection-and-Intersection-Node"><a href="#Two-Linked-List-Intersection-and-Intersection-Node" class="headerlink" title="Two Linked List Intersection and Intersection Node"></a>Two Linked List Intersection and Intersection Node</h2><p>判断连个单链表是否相交经典算法是判断两个链表最后一位是否一样，如果一样，则相交。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span></span>&#123;</div><div class="line">    ListNode tailA = headA;</div><div class="line">    <span class="keyword">while</span>(tailA.next != <span class="keyword">null</span>)&#123;</div><div class="line">    	tailA = tailA.next;</div><div class="line">    &#125;</div><div class="line">    ListNode tailB = headB;</div><div class="line">    <span class="keyword">while</span>(tailB.next != <span class="keyword">null</span>)&#123;</div><div class="line">    	tailB = tailB.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tailA == tailB;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果返回两个链表相交的点，采用对齐法，快慢指针演变。先计算长度，再设计快慢指针，同时向前.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(headA == <span class="keyword">null</span>||headB == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">int</span> heightA = ListHeight(headA);</div><div class="line">    ListNode a = headA;</div><div class="line">    <span class="keyword">int</span> heightB = ListHeight(headB);</div><div class="line">    ListNode b = headB;</div><div class="line">    <span class="keyword">int</span> diff = Math.abs(height-heightB);</div><div class="line">    <span class="keyword">if</span>(heightA &lt; heightB)&#123;</div><div class="line">    	<span class="keyword">while</span>(diff &gt; <span class="number">0</span>)&#123;</div><div class="line">            b = b.next;</div><div class="line">            diff--;</div><div class="line">        &#125;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">    	<span class="keyword">while</span>(diff &gt; <span class="number">0</span>)&#123;</div><div class="line">            a = a.next;</div><div class="line">            diff--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(a != <span class="keyword">null</span>)&#123;</div><div class="line">    	<span class="keyword">if</span>(a==b)&#123;</div><div class="line">        	<span class="keyword">return</span> a;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">        	a = a.next;</div><div class="line">            b = b.next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">ListHeight</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">    ListNode pointer = head;</div><div class="line">    <span class="keyword">int</span> counter = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(pointer.next != <span class="keyword">null</span>)&#123;</div><div class="line">    	pointer = pointer.next;</div><div class="line">        counter++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> counter;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Merge-K-sorted-Lists"><a href="#Merge-K-sorted-Lists" class="headerlink" title="Merge K sorted Lists"></a>Merge K sorted Lists</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(List&lt;ListNode&gt; lists)</span> </span>&#123;  </div><div class="line">	<span class="comment">// write your code here</span></div><div class="line">	<span class="keyword">if</span> (lists==<span class="keyword">null</span>||lists.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	PriorityQueue&lt;ListNode&gt; queue= <span class="keyword">new</span> PriorityQueue&lt;ListNode&gt;(lists.size(),<span class="keyword">new</span> Comparator&lt;ListNode&gt;()&#123;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode o1, ListNode o2)</span> </span>&#123;</div><div class="line">			<span class="keyword">return</span> o1.val - o2.val;</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line"></div><div class="line">	ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">	ListNode tail=dummy;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (ListNode node:lists)</div><div class="line">		<span class="keyword">if</span> (node!=<span class="keyword">null</span>)</div><div class="line">			queue.add(node);</div><div class="line"></div><div class="line">	<span class="keyword">while</span> (!queue.isEmpty())&#123;</div><div class="line">		tail.next=queue.poll();</div><div class="line">		tail=tail.next;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (tail.next!=<span class="keyword">null</span>)</div><div class="line">			queue.add(tail.next);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> dummy.next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Linked-List-Cycle"><a href="#Linked-List-Cycle" class="headerlink" title="Linked List Cycle"></a>Linked List Cycle</h2><p><a href="http://wuchong.me/blog/2014/03/25/interview-link-questions/" target="_blank" rel="external">答案来自网络</a><br>通过两个指针，分别从链表的头节点出发，一个每次向后移动一步，另一个移动两步，两个指针移动速度不一样，如果存在环，那么两个指针一定会在环里相遇。按照 p2 每次两步，p1 每次一步的方式走，发现 p2 和 p1 重合，确定了单向链表有环路了。接下来，让p2回到链表的头部，重新走，每次步长不是走2了，而是走1，那么当 p1 和 p2 再次相遇的时候，就是环路的入口了。</p>
<p>为什么？：假定起点到环入口点的距离为 a，p1 和 p2 的相交点M与环入口点的距离为b，环路的周长为L，当 p1 和 p2 第一次相遇的时候，假定 p1 走了 n 步。那么有：</p>
<p>p1走的路径： a+b ＝ n；<br>p2走的路径： a+b+k<em>L = 2</em>n； p2 比 p1 多走了k圈环路，总路程是p1的2倍</p>
<p>根据上述公式可以得到 k*L=a+b=n显然，如果从相遇点M开始，p1 再走 n 步的话，还可以再回到相遇点，同时p2从头开始走的话，经过n步，也会达到相遇点M。</p>
<p>显然在这个步骤当中 p1 和 p2 只有前 a 步走的路径不同，所以当 p1 和 p2 再次重合的时候，必然是在链表的环路入口点上。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;  </div><div class="line">       <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       ListNode slow = head;</div><div class="line">       ListNode fast = head;</div><div class="line">       <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;fast.next!=<span class="keyword">null</span>)&#123;</div><div class="line">           slow = slow.next;</div><div class="line">           fast = fast.next.next;</div><div class="line">           <span class="keyword">if</span>(fast==slow)&#123;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span>(fast!=slow) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       fast = head;</div><div class="line">       <span class="keyword">while</span>(fast!=slow)&#123;</div><div class="line">           fast = fast.next;</div><div class="line">           slow = slow.next;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> fast;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/03/02/Basic-Algorithm-Questions-Updating-all-the-time/" class="prev">PREV</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://yoursite.com">Xiufeng Chen</a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>